#+TITLE: Pjotr's hacking guide to GNU Guix

* Table of Contents                                                     :TOC:
 - [[#introduction][Introduction]]
 - [[#guile-the-language][Guile, the language]]
   - [[#functions-vs-procedures][Functions vs procedures]]
   - [[#boolean-f-t-notation][Boolean #f, #t notation]]
   - [[#hash-colon--notation][Hash colon (#:) notation]]
   - [[#percentage--notation][Percentage (%) notation]]
   - [[#key-values][Key-values]]
   - [[#defining-a-function][Defining a function]]
   - [[#defining-a-variable][Defining a variable]]
   - [[#inside-functions][Inside functions]]
   - [[#more-about-guilescheme][More about Guile/scheme]]
 - [[#guix-the-language][Guix, the language]]
   - [[#expressions][Expressions]]
   - [[#bags][Bags]]
   - [[#renaming-and-moving-files][Renaming and moving files]]
 - [[#starting-the-daemon][Starting the daemon]]
 - [[#install-guix-from-the-git-repository][Install Guix from the git repository]]
 - [[#creating-a-package][Creating a package]]
   - [[#updating-the-version][Updating the version]]
   - [[#updating-the-hash-value][Updating the HASH value]]
   - [[#use-import-to-convert-other-packages-from-gnu-pypi-rubygems-and-nix][Use import to convert other packages from GNU, pypi, rubygems and Nix]]
   - [[#dependencies][Dependencies]]
 - [[#building-the-package][Building the package]]
 - [[#debugging-the-package][Debugging the package]]
   - [[#environment][Environment]]
   - [[#inside-guile-repl][Inside Guile (REPL)]]
   - [[#using-the-debugger-][Using the debugger ]]
   - [[#the-user-init-file][The user init file]]
   - [[#running-a-guile-script][Running a Guile script]]
   - [[#in-progress-using-guile-in-emacs-geiser][IN PROGRESS Using guile in emacs (geiser)]]
 - [[#fixing-problems][Fixing problems]]
 - [[#installing-the-package][Installing the package]]
 - [[#using-the-search-path][Using the search path]]
 - [[#making-a-patch-to-submit-to-the-mailing-list][Making a patch to submit to the mailing list]]
   - [[#mail-the-patch][Mail the patch]]
   - [[#using-git-branches][Using git branches]]
   - [[#dealing-with-the-review-process][Dealing with the review process]]
 - [[#workflow-for-packaging][Workflow for packaging]]
 - [[#hints][Hints]]
   - [[#using-emacs][Using emacs]]
   - [[#filing-a-bug][Filing a bug]]
 - [[#the-ruby-package][The Ruby package]]
   - [[#ruby-gems][Ruby Gems]]
 - [[#dealing-with-special-packages][Dealing with special packages]]
 - [[#create-a-caching-server][Create a caching server]]

* Introduction

'You are in a maze of twisty packages all alike...'

Hacking GNU Guix is an adventure. Not least because it is using Scheme
LISP in the GNU Ubiquitous Intelligent Language for Extensions
implementation, also known as Guile. You are encouraged to dive in to
LISP, a language that is so good it simply refuses to go away.

GNU Guix stands out as the 'hackable' package manager. Mostly because
it uses a powerful high-level programming language.

This document should get you started with Guile and GNU Guix. Just pick
any package description in the ./gnu directory and work from there. The
examples here are pulled from the ruby.scm package.

Once you have a running GNU Guix (see INSTALL), the next step is to
compile a package from a recent git checkout of the sources. Check out
the source tree following the instructions in the manual. Here we
start from a checked out GNU Guix git repository.

First a note of caution. Try to work one step at a time. GNU Guix is not
a simple system, so you are bound to get frustrated. But it is hackable,
that means you can solve any problem! And the reward is sane software
deployment. Guix will pay back your investment.

Before hacking GNU Guix it may be worth contemplating the speed of the
network connection: in short, the faster the better. Caching packages
somewhere may be worth considering too. Finally a fast server may be a
good thing too because GNU Guix is designed to build packages in parallel.

* Guile, the language

Guile is a Scheme LISP. Here we list some Scheme specific material that is used
by GNU Guix. There is much information on the web on Scheme. Check out 
[[http://www.troubleshooters.com/codecorn/scheme_guile/hello.htm][Scheme at a Glance]], for example.

** Functions vs procedures

In the Scheme world, we prefer to use the word `procedure' instead of
`function', to reflect the fact that it is not merely a mapping from
inputs to outputs but can perform side effects as well.

In this document I carelessly mix the two terms, you are warned.

** Boolean #f, #t notation

#f signifies false, #t signifies true.

** Hash colon (#:) notation

The #: signifies literal keyword syntax and is used to 
create unique identifiers, see also

  http://practical-scheme.net/wiliki/schemexref.cgi?keyword%3F

in Ruby, for comparison, #:key would be in colon notation :key (which
is known as a symbol in Ruby, but differs from a symbol in LISP).

** Percentage (%) notation

The percentage is a syntactical name helper used to generate and
create values available in scope.  For example, the output file name
is reified via the %output variable automatically added to builderâ€™s
scope. Input file names are similarly reified through the
%build-inputs variable. Both variables are non-hygienically introduced
in the build expression by build-expression->derivation.

Note that it is merely a convention, like '_' in C.  Scheme LISP treats '%'
exactly the same as any other letter.

** Key-values

GNU Guix uses key-value pairs extensively. With

#+begin_src scheme
  (build-system
    (name 'ruby)
    (description "The standard Ruby build system")
    (lower lower)))
#+end_src

the Guix build-system record constructor is called with the field
names name, description and lower, where the last is a function with
the same name. These definitions are actually resolved as [[http://www.scheme.com/tspl4/records.html][Guile
records]] can be found in ./guix/packages.scm.  Look up
'define-record-type*' defined in ./guix/build-system.scm to see how
that works (the asterisk * implies that fields are bound as per
letrec*, allowing them to refer to one another):

#+begin_src scheme
(define-record-type* <build-system> build-system make-build-system
  build-system?
  (name        build-system-name)         ; symbol
  (description build-system-description)  ; short description
  (lower       build-system-lower))       ; args ... -> bags

;; "Bags" are low-level representations of "packages".  The system and target
;; of a bag is fixed when it's created.  This is because build systems may
;; choose inputs as a function of the system and target.
(define-record-type* <bag> bag %make-bag
  bag?
  (name          bag-name)               ;string

  (system        bag-system)             ;string
  (target        bag-target              ;string | #f
                 (default #f))

  ;; Here we use build/host/target in the sense of the GNU tool chain (info
  ;; "(autoconf) Specifying Target Triplets").
  (build-inputs  bag-build-inputs        ;list of packages
                 (default '()))
  (host-inputs   bag-host-inputs         ;list of packages
                 (default '()))

  ;; "Target inputs" are packages that are built natively, but that are used
  ;; by target programs in a cross-compilation environment.  Thus, they act
  ;; like 'inputs' as far as search paths are concerned.  The only example of
  ;; that is the cross-libc: it is an input of 'cross-gcc', thus built
  ;; natively; yet, we want it to be considered as a target input for the
  ;; purposes of $CPATH, $LIBRARY_PATH, etc.
  (target-inputs bag-target-inputs
                 (default '()))
  (outputs       bag-outputs             ;list of strings
                 (default '("out")))
  (arguments     bag-arguments           ;list
                 (default '()))
  (build         bag-build))             ;bag -> derivation
#+end_src

In GNU Guix the record data is available as build-system-name,
build-system-description etc. Same for the package record which
delivers package-name, package-version, etc. 

Also literal keywoard syntax is used, e.g.,

#+begin_src scheme
  (build-expression->derivation store name builder
                                #:inputs inputs
                                #:system system
                                #:modules imported-modules
                                #:outputs outputs
                                #:guile-for-build guile-for-build))
#+end_src

calls build-expression->derivation (note that Guile can
use more than alphanum characters to create a function name) with
parameters store, name, builder and a list of variable key-value pairs
named #:inputs, inputs etc. The idea is that the number of parameters
is variable to the build-expression->derivation function.

** Defining a function

define and define* are used to define functions - well actually to
bind identifiers to any value. Note that functions are defined in a
module or function local scope. define-module at the top of a package
can export functions, e.g.

#+begin_src scheme
  (define-module (guix build-system ruby)
    #:use-module (guix store)
    #:export (ruby-build
              ruby-build-system))
#+end_src

The difference between define and define* is that the latter can handle
variable length parameter lists.

A thing to note is that every LISP function returns a value, i.e., the last
expression evaluated.

** Defining a variable

let and let* allow defining multiple variables in scope. The
difference between let and let* is that let* guarantees sequential
initialization, so you can cross-reference values in the list. The
more important difference between let and let* is that let* allows the
initializers of later variables to refer to the earlier variables,
whereas the initializers of let only see variables outside of the let.
For example:

#+begin_src scheme
      (let ((a 1) (b 2))
        (let ((b a) (a b))
          (list a b)))

     returns (2 1), but if the inner let is replaced with let*, then it
     will return (1 1).
#+end_src

** Inside functions

One thing to note is the extensive use of backquote in GNU
Guix. Backquote (quasiquote in Scheme LISP jargon) is like quote, but
selected subexpressions are evaluated. These are assigned with a
comma (an unquote), e.g.

#+begin_src scheme
       (ruby-build #:name ,name
                   #:source ,(match (assoc-ref inputs "source")
                               (((? derivation? source))
                                (derivation->output-path source))
                               ((source)
                                source)
                               (source
                                source))
                   #:system ,system
                   #:test-target ,test-target
                   #:tests? ,tests?
                   #:phases ,phases
#+end_src

Note match operator which is used for expression matching. Here 'source'
is matched to pull out the source path and generate a #:source key-value pair.

When ,@ is used (shorthand for unquote-splicing), e.g. in

#+begin_src scheme
         (host-inputs `(,@(if source
                              `(("source" ,source))
                              '())
                        ,@inputs

                        ;; Keep the standard inputs of 'gnu-build-system'.
                        ,@(standard-packages)))
#+end_src

it indicates an expression to be evaluated and the elements of the
returned list inserted (the resulting list is 'spliced in').

** More about Guile/scheme

Use your editor to jump to function definitions inside the GNU Guix
source tree. With emacs you can use 'ctags -R -e' in the base
directory and load the TAGS file.  Jump to a tag with M-x find-tag. If
that does not find the tag, look the function up in the Guile manual.

Guile/scheme is a minimalistic implementation of LISP (though Guile is
moderately large for a Scheme). This means it is pretty easy to learn
the language.  To read up on available functionality, read the Guile
manual online or in PDF. The procedure index contains all available
function calls for the language.

Running Guile stand-alone is easy using a command line REPL or inside emacs.
That allows you to play with language features, as well as call 
GNU Guix functionality directly.

* Guix, the language

GNU Guix is not a language per se. But as they say, LISP is used to
create a new language for every purpose (using macros). So here we
list some of the commonly used macros.

** Expressions

A good explanation of expressions (a derivation in Nix-speak) and how
they are implemented can be found on [[https://en.wikisource.org/wiki/Functional_Package_Management_with_Guix/Build_expressions_and_package_descriptions][Wikisource]]. Actually at the low 
level an expression returns a derivation variable or structure.

** Bags

Recently GNU Guix introduced bags as an intermediate form between packages
and derivations. A bag includes all the implicit inputs which is useful 
for processing.

** Renaming and moving files

Replace the install phase with a function that adds /bin to outputs
and makes sure to make the directory and copy a file named mpc123 into
bin:

#+begin_src scheme
    (alist-replace
     'install
     (lambda* (#:key outputs #:allow-other-keys)
       (let* ((out (assoc-ref outputs "out"))
              (bin (string-append out "/bin")))
         (mkdir-p bin)
         (copy-file (string-append bin "/mpc123") (string-append bin "/mpc123"))))
#+end_src

*** TODO show the newer 'modify-phases' syntax instead

* Starting the daemon

Do not forget to start the daemon

#+begin_src scheme
  guix-daemon --build-users-group=guix-build
#+end_src

The daemon runs ar root, the actual build processes run as unprivileged users.

* Install Guix from the git repository

See the section [[https://github.com/pjotrp/guix-notes/blob/master/INSTALL.org#building-gnu-guix-from-source-using-guix][Building GNU Guix from source]] in [[https://github.com/pjotrp/guix-notes/blob/master/INSTALL.org][INSTALL]].

* Creating a package
** Updating the version

The version is located in the package definition. E.g.

#+begin_src scheme
(define-public ruby-2.1
  (package (inherit ruby)
    (version "2.1.6")
    (source
     (origin
       (method url-fetch)
       (uri (string-append "http://cache.ruby-lang.org/pub/ruby/"
                           (version-major+minor version)
                           "/ruby-" version ".tar.bz2"))
       (sha256
        (base32
         "1r4bs8lfwsypbcf8j2lpv3by40729vp5mh697njizj97fjp644qy"))))
#+end_src

** Updating the HASH value

#+begin_src scheme
  guix download http://cache.ruby-lang.org/pub/ruby/2.1/ruby-2.1.3.tar.gz
#+end_src

** Use import to convert other packages from GNU, pypi, rubygems and Nix

Guix can read package definitions from other sources and write a Guix expression to stdout.
Make sure gnutls is installed (to avoid a JSON error) and

: guix package -i gnutls
: guix import pypi readline

prints out

#+begin_src scheme
(package
  (name "python-readline")
  (version "6.2.4.1")
  (source
    (origin
      (method url-fetch)
      (uri (string-append
             "https://pypi.python.org/packages/source/r/readline/readline-"
             version
             ".tar.gz"))
      (sha256
        (base32
          "01yi9cls19nglj0h172hhlf64chb0xj5rv1ca38yflpy7ph8c3z0"))))
  (build-system python-build-system)
  (inputs
    `(("python-setuptools" ,python-setuptools)))
  (home-page
    "http://github.com/ludwigschwardt/python-readline")
  (synopsis
    "The standard Python readline extension statically linked against the GNU readline library.")
  (description
    "The standard Python readline extension statically linked against the GNU readline library.")
  (license #f))
#+end_src scheme

** Dependencies

All software (except for the Linux kernel) depends on other software to build
or to run. Guix keeps track of them and by adding a dependency all underlying
dependencies get pulled in too. The build systems will pull in the usual dependencies,
but often you need to specify a few more. Guix understands the following inputs

1. *native-inputs*: required for building but not runtime - installing a
   package through a substitute won't install these inputs
2. *inputs*: installed in the store but not in the profile, as well as being
   present at build time
3. *propagated-inputs*: installed in the store and in the profile, as
   well as being present at build time

* Building the package

From a prebuilt guix in the source tree one can start with

#+begin_src scheme
  ./pre-inst-env guix package -A ruby
    ruby    1.8.7-p374      out     gnu/packages/ruby.scm:119:2
    ruby    2.1.6   out     gnu/packages/ruby.scm:91:2
    ruby    2.2.2   out     gnu/packages/ruby.scm:39:2
#+end_src

to see if the package compiles. Note that Guix contains three versions
of Ruby!  Next try the explicit package compile which should return
the destination

#+begin_src scheme
  ./pre-inst-env guix build -K -e '(@ (gnu packages ruby) ruby-2.1)' 
  /gnu/store/c13v73jxmj2nir2xjqaz5259zywsa9zi-ruby-2.1.6
#+end_src

* Debugging the package
** Environment

Before debugging it is important to have a clean environment. 

You can view the environment variable definitions Guix recommends with

: guix package --search-paths

Mine looks like:

#+begin_src sh
set|grep guix
  ACLOCAL_PATH=/home/pjotr/.guix-profile/share/aclocal
  BASH=/home/pjotr/.guix-profile/bin/bash
  CPATH=/home/pjotr/.guix-profile/include
  GUILE_LOAD_COMPILED_PATH=/home/pjotr/.guix-profile/share/guile/site/2.0
  GUILE_LOAD_PATH=/home/pjotr/.guix-profile/share/guile/site/2.0
  LIBRARY_PATH=/home/pjotr/.guix-profile/lib
  LOCPATH=/home/pjotr/.guix-profile/lib/locale
  PATH=/home/pjotr/.guix-profile/bin:/home/pjotr/.guix-profile/sbin
  PKG_CONFIG_PATH=/home/pjotr/.guix-profile/lib/pkgconfig
#+end_src

** Inside Guile (REPL)

With most packaging systems the only way to debug them is by sprinkling print
statements, using a debugger or hoping for the best (TM). The equivalent in
a guix expression would be, for example

#+begin_src scheme
 (pk 'ECHO (which "echo"))
#+end_src scheme

GNU Guix is written in scheme lisp with the GNU Guile interpreter/compiler. This means
code can be run and data can be inspected in the REPL.

From the command line with guile use the [[https://www.gnu.org/software/guile/manual/html_node/The-REPL.html][REPL]] like this:

#+begin_src scheme
  $ ./pre-inst-env guile
    GNU Guile 2.0.11
    Copyright (C) 1995-2014 Free Software Foundation, Inc.

  Enter `,help' for help.
  scheme@(guile-user)> 
  ;;; read-line support
  (use-modules (ice-9 readline))
  (activate-readline)
  ;;; help may come in useful
  ,help
  ;;; some LISP
  (define a 3)
  a
  ;;; $1 = 3
  ,pretty-print a
  ;;; $2 = 3
#+end_src 

Load guix (the leading comma interprets the command)

#+begin_src scheme
  ,use (gnu packages ruby)
  ,use (guix)
  ,use (guix build-system)
#+end_src

Note that the order of gnu/packages/ruby is simply the directory structure of the git
repository. Now start talking with the daemon

#+begin_src scheme
  (define s (open-connection))
  ruby
  ;;; $1 = #<package ruby-2.2.2 gnu/packages/ruby.scm:39 2ed9f00>
  ruby-2.1
  ;;; $1 = #<package ruby-2.1.6 gnu/packages/ruby.scm:91 36f10c0>
  (package-derivation s ruby)
  ;;; $2 = #<derivation /gnu/store/cvsq4yijavhv7vj7pk3ns0qmvvxdp935-ruby-2.2.2.drv => /gnu/store/66nc9miql9frizn0v02iq1siywsq65w5-ruby-2.2.2 3a9d7d0>
  ,pretty-print s
  ;;; $3 = #<build-daemon 256.14 32b7800>
#+end_src

*** Inspect package (and bag)

Let's inspect the package using the methods defined in guix/packages.scm

#+begin_src scheme
(define p ruby)
(package-name p)
;;; "ruby"
(package-inputs p)
;;; (("readline" #<package readline-6.3 gnu/packages/readline.scm:39 2aa2840>) 
;;; ("openssl" #<package openssl-1.0.2b gnu/packages/openssl.scm:30 2f15d80>) 
;;; ("libffi" #<package libffi-3.1 gnu/packages/libffi.scm:34 2b8b900>) 
;;; etc.
(package->bag p)
 

$22 = #<<bag> name: "ruby-2.2.2" system: "x86_64-linux" target: #f 
build-inputs: (
("source" #<origin "http://cache.ruby-lang.org/pub/ruby/2.2/ruby-2.2.2.tar.xz" 6az3luekwvyihzemdwa3zvzztftvpdbxbnte3kiockrsrekcirra () 36f28c0>)
("tar" #<package tar-1.28 gnu/packages/bootstrap.scm:145 3953540>)
("gzip" #<package gzip-1.6 gnu/packages/bootstrap.scm:145 39533c0>)
("bzip2" #<package bzip2-1.0.6 gnu/packages/bootstrap.scm:145 3953240>) 
("xz" #<package xz-5.0.4 gnu/packages/bootstrap.scm:145 39530c0>) 
("file" #<package file-5.22 gnu/packages/bootstrap.scm:145 395cf00>) 
("diffutils" #<package diffutils-3.3 gnu/packages/bootstrap.scm:145 395cd80>) 
("patch" #<package patch-2.7.5 gnu/packages/bootstrap.scm:145 395cc00>) 
("sed" #<package sed-4.2.2 gnu/packages/bootstrap.scm:145 395ca80>) 
("findutils" #<package findutils-4.4.2 gnu/packages/bootstrap.scm:145 395c900>)
("gawk" #<package gawk-4.1.1 gnu/packages/bootstrap.scm:145 395c780>)
("grep" #<package grep-2.21 gnu/packages/bootstrap.scm:145 39536c0>)
("coreutils" #<package coreutils-8.23 gnu/packages/bootstrap.scm:145 3953840>) 
("make" #<package make-4.1 gnu/packages/bootstrap.scm:145 3953a80>) 
("bash" #<package bash-4.3.33 gnu/packages/bootstrap.scm:145 3953e40>) 
("ld-wrapper" #<package ld-wrapper-0 gnu/packages/commencement.scm:644 39539c0>) 
("binutils" #<package binutils-2.25 gnu/packages/bootstrap.scm:145 394d3c0>) 
("gcc" #<package gcc-4.8.4 gnu/packages/commencement.scm:530 394d180>)
("libc" #<package glibc-2.21 gnu/packages/commencement.scm:454 394d600>) 
("locales" #<package glibc-utf8-locales-2.21 gnu/packages/commencement.scm:621 3953c00>)
) 
host-inputs: (
("readline" #<package readline-6.3 gnu/packages/readline.scm:39 2aa2840>)
("openssl" #<package openssl-1.0.2b gnu/packages/openssl.scm:30 2f15d80>) 
("libffi" #<package libffi-3.1 gnu/packages/libffi.scm:34 2b8b900>) 
("gdbm" #<package gdbm-1.11 gnu/packages/gdbm.scm:26 2b8b6c0>) 
("zlib" #<package zlib-1.2.7 gnu/packages/compression.scm:33 36f1c00>)
) 
target-inputs: () 
outputs: ("out") 
arguments: (#:system "x86_64-linux" #:test-target "test" #:parallel-tests? #f #:phases
(alist-cons-before (quote configure) (quote replace-bin-sh) 
  (lambda _ (substitute* (quote ("Makefile.in" "ext/pty/pty.c" "io.c"
"lib/mkmf.rb" "process.c" "test/rubygems/test_gem_ext_configure_builder.rb"
"test/rdoc/test_rdoc_parser.rb" "test/ruby/test_rubyoptions.rb"
"test/ruby/test_process.rb" "test/ruby/test_system.rb"
"tool/rbinstall.rb")) 
(("/bin/sh") (which "sh")))) %standard-phases)
)
build: #<procedure gnu-build (store name input-drvs #:key guile
outputs search-paths configure-flags make-flags out-of-source? tests?
test-target parallel-build? parallel-tests? patch-shebangs?
strip-binaries? strip-flags strip-directories validate-runpath? phases
locale system imported-modules modules substitutable?
allowed-references)>>
#+end_src scheme

where bag is the actual data that gets passed to the build system.

*** Store monad and G-expressions

Guix uses [[https://www.gnu.org/software/guix/manual/html_node/The-Store-Monad.html][monad to handle the store state]]. Read up on these and [[https://www.gnu.org/software/guix/manual/html_node/G_002dExpressions.html#G_002dExpressions][G-expressions]]
if you intend to hack Guix. To run a procedure within a Store do something like

#+begin_src scheme
,use (guix git-download)
(git-reference (url "https://github.com/pjotrp/genenetwork2.git") (commit "860bdcebde5cbb1898c26da80ac67207480c0803"))
$3 = #<<git-reference> url: "https://github.com/pjotrp/genenetwork2.git" commit: "860bdcebde5cbb1898c26da80ac67207480c0803" recursive?: #f>
,enter-store-monad
   (git-fetch $3 'sha256
                  (base32
                   "0yvkv7pnigvcifas3vcr8sk87xrrb8y9nh9v1yx2p43k0xz1q8vz"))

$4 = #<derivation /gnu/store/fmpk2sck6ny5dgyx12s539qcadzky24n-mypackage.drv => /gnu/store/k6q69arfmsm116a8hfkqqah
m0ddzacjc-mypackage 50b9e10>
#+end_src scheme

Here $3 is the git-reference record and $4 is a derivation object, and
calling â€˜built-derivationsâ€™ starts the build process

#+begin_src scheme
(built-derivations (list $4))
building path(s) `/gnu/store/fid19bds4rak2zn8pzfhrjdcpmqwhjn4-module-import'
building path(s) `/gnu/store/vf1pmac8yz2g0d4ln5ibwg0xaffdrnpq-module-import-compiled'
building path(s) `/gnu/store/k6q69arfmsm116a8hfkqqahm0ddzacjc-mypackage'
(...)
#+end_src scheme

#+begin_src scheme
  (run-with-store s
    (git-fetch ref ...))
#+end_src scheme

The principle of a monad is simply to handle `state' (here the store)
outside the called procedures (here the package builder). This
prevents passing around state parameters all the time leading to
simpler code. For a description of how monads can be implemented in
Guile, read [[http://okmij.org/ftp/Scheme/monad-in-Scheme.html][Chris Okasaki brilliant writeup `Monadic Programming in
Scheme']]. If you are a Ruby guy (like me) and want to understand
monads, read [[http://codon.com/refactoring-ruby-with-monads][Tom Stuart's more gentle `Refactoring Ruby with Monads']].

** Using the debugger 

It is also possible to [[https://www.gnu.org/software/guile/manual/html_node/Debug-Commands.html][step through code]] and view progress and the
contents of variables at every stage. The debugger comes with Guile by
default. You can set breakpoints and step through code with step,
next and finish.

** The user init file

You can set up an init file that gets loaded every time Guile gets
started in interactive mode. Mine contains:

#+begin_src scheme
;; Init file in ~/.guile

;;; read-line support
(use-modules (ice-9 readline))
 (activate-readline)
 
;;; GNU Guix
(use-modules (guix hash) (guix) (guix build-system))

#+end_src scheme

** Running a Guile script

Instead of using the Guile REPL is is also possible to run the code as
a [[https://www.gnu.org/software/guile/manual/html_node/Scripting-Examples.html#Scripting-Examples][script]]. Create a script:

#+begin_src scheme
(define-module (gnu packages mytest)
  #:use-module (gnu packages ruby)
  #:use-module (guix)
  )

(define s (open-connection))
(define p ruby-2.1)

(write (package->bag p))
(newline)(newline)
(write (string-append (package-name p) "-" (package-version p)))
#+end_src scheme

Run it as

: ./pre-inst-env guile -s test.scm
: (lots of info)
:
: "ruby-2.1.6"

** IN PROGRESS Using guile in emacs (geiser)

But the best thing, if you use Emacs, is to use Geiser, as noted in
â€˜HACKINGâ€™.  In addition to a REPL, it brings stuff like autodoc,
jump-to-definition, expression evaluation from the buffer, etc.

Install Geiser and add the guile path to ~/.emacs with

#+begin_src scheme
  (setq-default geiser-guile-load-path '("~/src/guix"))
#+end_src

Start geiser and you should be able to replicate above commands.

* Fixing problems

Compiling the package there may be build problems. cd into the build directory

#+begin_src scheme
  cd /tmp/nix-build-ruby-2.1.3.drv-0
#+end_src

and 

#+begin_src scheme
  . environment-variables
#+end_src

will recreate the build environment. Now you can see where the build stopped by running
commands.
  
* Installing the package

Once the build works you can use standard guix to install the package

#+begin_src scheme
  ./pre-inst-env guix package -i ruby
#+end_src

This will also build from the source tree and blindly merges that
directory into your profile, but lacks information for updates etc:

#+begin_src scheme
  ./pre-inst-env guix package -e '(@ (gnu packages ruby) ruby)'
#+end_src

#+begin_src scheme
  guix package -i $(guix build ruby)
#+end_src

Where (guix build ruby) is a LISP call which translates into a raw
path.  With the last example, passing a raw directory name to "guix
package -i" does not really know what package it is, so it just
blindly merges that directory into your profile. Later upgrades,
propagated inputs, and search-path advisories aren't handled
correctly.

* Using the search path

One can run:

:  GUIX_PROFILE=$HOME/.guix-profile . ~/.guix-profile/etc/profile

or

:  eval `guix package --search-paths`

See <http://www.gnu.org/software/guix/manual/html_node/Invoking-guix-package.html>.

And nowadays one can also use --search-paths=suffix or
--search-paths=prefix, for more flexibility.

* Making a patch to submit to the mailing list

Check the Guix guidelines [[https://www.gnu.org/software/guix/manual/html_node/Submitting-Patches.html#Submitting-Patches][first]].

A patch can be sent to the mailing list. Use git rebase --interactive
to merge and [[http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html][squash patches]] into one. E.g., 

: git rebase -i HEAD~4

Next use the GNU ChangeLog
format which is a header with a filewise change description:

#+begin_src scheme
  gnu: Add Ruby.
    
  * gnu/packages/ruby.scm (Ruby): New file.
  * guix/licenses.scm: Add Ruby license information.
#+end_src

Use git format-patch to send a patch to the mailing list.  

You can set up an environment to hack on Guix by entering the clone
directory and running

#+begin_src scheme
    guix environment guix
#+end_src

Then you can just run make to see if everything builds fine.  If it
does, make a commit with an appropriate commit message, e.g. by using
git rebase (see the guix manual) or by creating a diff between
branches (useful when there are conflicts etc.)

#+begin_src bash
git diff master > intermediate.patch
git checkout master
git checkout -b submit_branch
patch -p1 < intermediate.patch
git commit -a
#+end_src

and use

#+begin_src bash
    git format-patch -1
#+end_src

to generate a patch file, which you can then send to the Guix-devel
mailing list (guix-devel@gnu.org). To generate the last 2 patches use -2.

To change the last commit message do

: git commit --amend

Which creates a file 0001-gnu-patchname.patch.

Make sure tabs are turned into spaces. The emacs commands are
[[http://www.emacswiki.org/emacs/NoTabs][here]]. Lines should be broken (use M-q in emacs). And use the Emacs TAB
to find the right LISP indendation. 

To change credentials for the patch use the [[https://help.github.com/articles/setting-your-email-in-git/][git config]] command.

** Mail the patch

Initially you can mail the patch as an attachment to the mailing
list. But better is to mail it as it is with something like (I use two steps
to validate the mail and send it from a different mail server)

#+begin_src bash
cat 0001-*.patch |formail -t -I "To: guix-devel@gnu.org" \
   -I "From: Pjotr Prins <pjotr.public12@email>" \
   -I "In-Reply-To: <20160213102825.GA19194@debian>" > mail.patch
cat mail.patch|formail -s mail -t ; rm mail.patch
#+end_src bash

after making sure the header contains something like

: From: Pjotr Prins <my.email>
: To: guix-devel <guix-devel@gnu.org>
: Subject: [PATCH]     gnu: Add ruby-libxml.
: 
:    * gnu/packages/ruby.scm (ruby-libxml): New variable.
: ---
: etc.

Note that the GNU Guix developers want one patch per variable. So
submit packages one at a time.

For more information see the official HACKING document in the Guix git
repo.

** Using git branches

It may be a good idea to keep the master branch in sync with that of Guix.
When adding something new checkout a branch first

: git checkout -b dev

Now to creat a patch to send to the mailing list do

: git commit -a -m 'My last commit'
: git checkout master
: git checkout -b submit
: git rebase --interactive dev

Squash the commits into one

** Dealing with the review process

When you write many patches that potentially depend on each other and
the review system get choked (the reviewers can't allways keep up) I
resort to a system where I develop patches in a separate source
repository. The patches I feed to the reviewers one at a time, so that
only when a patch gets accepted (or fully rejected) I send in the next
one. This is the most relaxed way of dealing with the GNU Guix patch
submission protocol. Remember that reviewers are people who put in
their spare time to to make sure GNU Guix is great. It can be annoying
when you disagree with a reviewer, but stay calm, be nice and try to
discuss the underlying issue. One example is the R-qtl thread.

One great advantage of handling one patch at a time is that it is much
easier to keep track with git and the mailing list. And because I have
a separate git tree, I can still use my own patches. For the separate
tree is makes sense to use a different name space (not the gnu
directory) and give the packages different names too - so that when
you overlap with the GNU Guix package tree there is no packaging
conflict. With the GeneNetwork tree we use the gn directory and
prepend package names with gn- so r-qtl becomes gn-r-qtl.

* Workflow for packaging

The general workflow for adding and maintaining packages is a bit
complex. Everything goes via de guix-dev mailing list and includes a
review process which can be discouraging and is more geared towards
reviewers than towards newbies. This should not discourage you because
GNU Guix is great. Note that the reviewers do this work voluntarily
and most 'rules' have been agreed by the community. In the end your
labours will get rewarded. So, how to start?

1. Work on a recent git checkout of guix 
2. Use 'guix import' if you can (e.g. for python and R modules)
3. Build the package yourself 
4. If tests are there, make sure they pass
5. Test your work with 'guix lint'
6. Create a patch as described above
7. Send it to the mailing list as described above
8. Submit one patch at a time and submit the next one when it goes in
9. Be patient, review can take a while - if it is a trivial patch
   monitor the git log

With small problems the reviewers will often modify the patch for you.
Larger problems you need to fix yourself. See it as a learning
process.

Note: sometimes I use an older GNU Guix tree since it is a work in
progress and the master may fail for whatever reason. Simply use git
cherry-pick to update a single module and it should still work to
submit a patch.

* Hints

Read the HACKING documentation in the Guix source tree.

There are also videos on hacking in gnu.org/s/guix. 

** Using emacs

Emacs has powerful support for editing LISP (unsurprisingly, perhaps).

*** Key binding

+ C-M-f and C-M-b move to forward/backward to matching braces

** Filing a bug

Send a mail to the bug list, it should look like this:

#+begin_src scheme
From: Pjotr Prins <pjotr.public12@email>
To: bug-guix@gnu.org
Bcc: 
Subject: guix lint fails with -dc switch missing
Reply-To: 

When I run lint on a recent ceckout

  ./pre-inst-env guix lint 
  
or
  
  ./pre-inst-env guix lint python
  
I get
  
  filtered-port: failed to execute ' -dc ': No such file or directory

Backtrace: 
In unknown file:
   ?: 19 [apply-smob/1 #<catch-closure 16dfcc0>]
In ice-9/boot-9.scm:
  63: 18 [call-with-prompt prompt0 ...]
In ice-9/eval.scm:
 432: 17 [eval # #]
#+end_src scheme

* The Ruby package
** Ruby Gems

The first Ruby gem support by GNU Guix is ruby-i18n (internationalization). The 
definition looked like

#+begin_src scheme
  (define-public ruby-i18n
  (package
    (name "ruby-i18n")
    (version "0.6.11")
    (source (origin
              (method url-fetch)
              (uri (string-append "https://github.com/svenfuchs/i18n/archive/v"
                                  version ".tar.gz"))
              (sha256
               (base32
                "1fdhnhh1p5g8vibv44d770z8nq208zrms3m2nswdvr54072y1m6k"))))
    (build-system ruby-build-system)
    (arguments
     '(#:tests? #f)) ; requires bundler
    (synopsis "Internationalization library for Ruby")
#+end_src

so it downloads the tar ball. The build system looks like

#+begin_src scheme
(define ruby-build-system
  (build-system
    (name 'ruby)
    (description "The standard Ruby build system")
    (lower lower)))
#+end_src

which creates an expression using the standard build-system and the 
local lower function.

When you install it says

#+begin_src scheme
  The following environment variable definitions may be needed:
   export GEM_PATH="/home/pjotr/.guix-profile/lib/ruby/gems/2.1.3"
#+end_src

which contains

#+begin_src scheme
  ls /home/pjotr/.guix-profile/lib/ruby/gems/2.1.3/gems/i18n-0.6.11/
    gemfiles  lib  MIT-LICENSE  README.md  test
#+end_src
* Dealing with special packages

Some packages won't make it into GNU Guix. 

If you have need a special section, simply create a directory with
packages and add them to the GUIX_PACKAGE_PATH:

: export GUIX_PACKAGE_PATH="~/code/guix-special"

this is also useful for packages that are in Guix but that you would
like to customize, for instance with a different set of dependencies
or different build flags. Make sure it is a full module, a simple
module would be:

#+begin_src scheme
(define-module (pylmm)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module (gnu packages)
  #:use-module (gnu packages python)
  #:use-module (guix download)
  #:use-module (guix packages)
  #:use-module (guix git-download)
  #:use-module (guix utils)
  #:use-module (guix build-system gnu)
  #:use-module (guix build-system python)
  #:use-module (guix build-system trivial)
  #:use-module (srfi srfi-1))

(define-public python-pylmm
  (package
    (name "python-pylmm")
    (version "1.0.0")
    (source
     (origin
       (method url-fetch)
       (uri (string-append
             "https://pypi.python.org/packages/source/p/pylmm/pylmm-"
             version ".tar.gz"))
       (sha256
        (base32 "0bzl9f9g34dlhwf09i3fdv7dqqzf2iq0w7d6c2bafx1nla98qfbh"))))
    (build-system python-build-system)
    (arguments '(#:tests? #f))
    (native-inputs
     `(("python-setuptools" ,python-setuptools)))
    (home-page "https://github.com/genenetwork/pylmm_gn2")
    (synopsis "Python LMM resolver")
    (description
      "Python LMM resolver")
    (license license:gpl-3)))

(define-public python2-pylmm
  (package-with-python2 python-pylmm))
#+end_src scheme

Save it as a file named pylmm.scm (the name of the module!) and add the path

: env GUIX_PACKAGE_PATH=~/python/pylmm_gn2/guix guix package -A python-pylmm 
:   python-pylmm    1.0.0   out     ~/python/pylmm_gn2/guix/pylmm.scm:15:2

* TODO Create a caching server

The Guix daemon contains a build server. It also can distribute built binaries.
